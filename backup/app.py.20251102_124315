from fastapi import FastAPI, UploadFile, File, Form, BackgroundTasks, HTTPException
from fastapi.staticfiles import StaticFiles
from fastapi.templating import Jinja2Templates
from fastapi.responses import HTMLResponse, FileResponse
from fastapi.requests import Request
import uvicorn
import os
import shutil
import subprocess
import asyncio
from pathlib import Path
import uuid
from typing import Optional, List
import json
import numpy as np
import mimetypes
import logging
import threading
from datetime import datetime, timedelta
from pydantic import BaseModel, Field, field_validator
import magic
import tempfile
from PIL import Image

# Import our chromakey function directly
from chromakey import remove_background_and_overlay_timed
from screen_recorder import ScreenRecorder, get_available_windows, get_screen_info
from metadata_ai import generate_metadata_from_transcription, merge_user_customizations, format_metadata_for_youtube
from video_translator import VideoTranslator
from youtube_uploader import YouTubeUploader

# Configurazione logging strutturato
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('app.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# Configurazione limiti
MAX_UPLOAD_SIZE = 500 * 1024 * 1024  # 500 MB
MAX_CONCURRENT_JOBS = 3
FILE_RETENTION_DAYS = 7
ALLOWED_VIDEO_MIMES = {
    'video/mp4', 'video/x-msvideo', 'video/quicktime',
    'video/x-matroska', 'video/webm'
}
ALLOWED_IMAGE_MIMES = {
    'image/png', 'image/jpeg', 'image/gif',
    'image/svg+xml', 'image/webp'
}

# Setup directories
UPLOAD_DIR = Path("uploads")
OUTPUT_DIR = Path("outputs")
STATIC_DIR = Path("static")
TEMPLATES_DIR = Path("templates")
JOBS_STATE_FILE = Path("jobs_state.json")

for directory in [UPLOAD_DIR, OUTPUT_DIR, STATIC_DIR, TEMPLATES_DIR]:
    directory.mkdir(exist_ok=True)

# Templates
templates = Jinja2Templates(directory=TEMPLATES_DIR)

# Thread-safe job management
class ProcessingJob:
    def __init__(self, job_id: str):
        self.job_id = job_id
        self.status = "pending"
        self.progress = 0
        self.message = "In attesa di elaborazione..."
        self.output_file = None
        self.error = None
        self.should_stop = False
        self.created_at = datetime.now()
        self.updated_at = datetime.now()
        self._lock = threading.Lock()

    def update(self, **kwargs):
        """Thread-safe update di attributi"""
        with self._lock:
            for key, value in kwargs.items():
                setattr(self, key, value)
            self.updated_at = datetime.now()

    def to_dict(self):
        """Serializza job per JSON"""
        with self._lock:
            return {
                "job_id": self.job_id,
                "status": self.status,
                "progress": self.progress,
                "message": self.message,
                "output_file": self.output_file,
                "error": self.error,
                "created_at": self.created_at.isoformat(),
                "updated_at": self.updated_at.isoformat()
            }

    @classmethod
    def from_dict(cls, data: dict):
        """Deserializza job da JSON"""
        job = cls(data["job_id"])
        job.status = data["status"]
        job.progress = data["progress"]
        job.message = data["message"]
        job.output_file = data.get("output_file")
        job.error = data.get("error")
        job.created_at = datetime.fromisoformat(data["created_at"])
        job.updated_at = datetime.fromisoformat(data["updated_at"])
        return job

# Global state con thread safety
processing_jobs = {}
jobs_lock = threading.Lock()

# Screen recorders attivi (per gestire stop)
active_recorders = {}
recorders_lock = threading.Lock()

# YouTube uploader instance
youtube_uploader = YouTubeUploader()

def save_jobs_state():
    """Salva stato jobs su disco"""
    try:
        with jobs_lock:
            state = {job_id: job.to_dict() for job_id, job in processing_jobs.items()}
        with open(JOBS_STATE_FILE, 'w') as f:
            json.dump(state, f, indent=2)
        logger.info(f"Stato jobs salvato: {len(state)} job(s)")
    except Exception as e:
        logger.error(f"Errore salvataggio stato jobs: {e}")

def load_jobs_state():
    """Carica stato jobs da disco"""
    try:
        if JOBS_STATE_FILE.exists():
            with open(JOBS_STATE_FILE, 'r') as f:
                state = json.load(f)
            with jobs_lock:
                for job_id, job_data in state.items():
                    # Ricarica solo job non completati/errore
                    if job_data["status"] in ["pending", "processing"]:
                        job_data["status"] = "error"
                        job_data["message"] = "Job interrotto da riavvio server"
                    processing_jobs[job_id] = ProcessingJob.from_dict(job_data)
            logger.info(f"Stato jobs caricato: {len(processing_jobs)} job(s)")
    except Exception as e:
        logger.error(f"Errore caricamento stato jobs: {e}")

def get_active_jobs_count():
    """Conta job attivi (pending/processing)"""
    with jobs_lock:
        return sum(1 for job in processing_jobs.values()
                  if job.status in ["pending", "processing"])

def cleanup_old_files():
    """Rimuove file pi√π vecchi di FILE_RETENTION_DAYS"""
    try:
        cutoff = datetime.now() - timedelta(days=FILE_RETENTION_DAYS)
        deleted_count = 0

        for directory in [UPLOAD_DIR, OUTPUT_DIR]:
            for file_path in directory.glob("*"):
                if file_path.is_file():
                    file_time = datetime.fromtimestamp(file_path.stat().st_mtime)
                    if file_time < cutoff:
                        file_path.unlink()
                        deleted_count += 1
                        logger.info(f"File rimosso (vecchio): {file_path.name}")

        if deleted_count > 0:
            logger.info(f"Cleanup completato: {deleted_count} file rimossi")
    except Exception as e:
        logger.error(f"Errore cleanup file: {e}")

# Pydantic models per validazione
class ProcessVideoRequest(BaseModel):
    foreground_file_id: str = Field(..., min_length=36, max_length=36)
    background_file_id: str = Field(..., min_length=36, max_length=36)
    start_time: float = Field(default=0.0, ge=0.0, le=3600.0)
    duration: Optional[float] = Field(default=None, ge=0.0, le=3600.0)
    audio_mode: str = Field(default="synced")
    cta_x_pos: int = Field(default=0, ge=-10000, le=10000)
    cta_y_pos: int = Field(default=0, ge=-10000, le=10000)
    cta_scale: float = Field(default=1.0, ge=0.1, le=10.0)
    opacity: float = Field(default=1.0, ge=0.0, le=1.0)
    fast_mode: bool = Field(default=True)
    gpu_mode: bool = Field(default=False)
    logo_file_id: Optional[str] = Field(default=None, min_length=36, max_length=36)
    logo_x_pos: Optional[int] = Field(default=None, ge=-10000, le=10000)
    logo_y_pos: Optional[int] = Field(default=None, ge=-10000, le=10000)
    logo_scale: Optional[float] = Field(default=None, ge=0.01, le=5.0)

    @field_validator('audio_mode')
    @classmethod
    def validate_audio_mode(cls, v):
        allowed = ['background', 'foreground', 'both', 'timed', 'synced', 'none']
        if v not in allowed:
            raise ValueError(f'audio_mode deve essere uno di: {allowed}')
        return v

# Lifespan events (sostituisce on_event deprecato)
from contextlib import asynccontextmanager

@asynccontextmanager
async def lifespan(app: FastAPI):
    """Gestione lifecycle app"""
    # Startup
    logger.info("üöÄ Avvio AI Video Maker")
    load_jobs_state()
    cleanup_old_files()
    yield
    # Shutdown
    logger.info("üíæ Salvataggio stato jobs...")
    save_jobs_state()

# Crea app con lifespan
app = FastAPI(
    title="üé¨ AI Video Maker",
    description="Chromakey Editor Professionale",
    version="1.0.0",
    lifespan=lifespan
)

# Mount static files DOPO la creazione di app
app.mount("/static", StaticFiles(directory=STATIC_DIR), name="static")
app.mount("/uploads", StaticFiles(directory=UPLOAD_DIR), name="uploads")
app.mount("/outputs", StaticFiles(directory=OUTPUT_DIR), name="outputs")

@app.get("/", response_class=HTMLResponse)
async def home(request: Request):
    return templates.TemplateResponse("index_new.html", {"request": request})

@app.get("/translation", response_class=HTMLResponse)
async def translation_page(request: Request):
    return templates.TemplateResponse("translation.html", {"request": request})

@app.get("/api/jobs/{job_id}")
async def get_job_status(job_id: str):
    with jobs_lock:
        if job_id not in processing_jobs:
            raise HTTPException(status_code=404, detail="Job non trovato")
        job = processing_jobs[job_id]

    response_data = job.to_dict()
    logger.debug(f"Status job {job_id}: {response_data['status']} ({response_data['progress']}%)")

    return response_data

@app.post("/api/upload")
async def upload_file(file: UploadFile = File(...)):
    # Validazione dimensione
    file_size = 0
    temp_file = None

    try:
        # Leggi file in memoria temporanea per validazione
        temp_file = tempfile.NamedTemporaryFile(delete=False)
        chunk_size = 1024 * 1024  # 1MB chunks

        while True:
            chunk = await file.read(chunk_size)
            if not chunk:
                break
            file_size += len(chunk)

            # Check size limit
            if file_size > MAX_UPLOAD_SIZE:
                temp_file.close()
                os.unlink(temp_file.name)
                raise HTTPException(
                    status_code=413,
                    detail=f"File troppo grande. Max: {MAX_UPLOAD_SIZE / 1024 / 1024:.0f}MB"
                )
            temp_file.write(chunk)

        temp_file.close()

        # Validazione MIME type
        mime = magic.Magic(mime=True)
        detected_mime = mime.from_file(temp_file.name)

        if detected_mime not in ALLOWED_VIDEO_MIMES and detected_mime not in ALLOWED_IMAGE_MIMES:
            os.unlink(temp_file.name)
            raise HTTPException(
                status_code=400,
                detail=f"Tipo MIME non supportato: {detected_mime}"
            )

        # Salva file: se √® una registrazione usa nome originale, altrimenti UUID
        if file.filename.startswith('recording_'):
            # Registrazione: usa nome originale
            final_filename = file.filename
            file_id = Path(file.filename).stem  # ID = nome senza estensione
        else:
            # Upload normale: usa UUID
            file_id = str(uuid.uuid4())
            file_extension = Path(file.filename).suffix.lower()
            final_filename = f"{file_id}{file_extension}"

        file_path = UPLOAD_DIR / final_filename

        # Se file esiste gi√†, sovrascrivi (per registrazioni con stesso timestamp)
        if file_path.exists():
            os.unlink(file_path)

        shutil.move(temp_file.name, file_path)

        logger.info(f"Upload completato: {file.filename} ({file_size / 1024 / 1024:.2f}MB) -> {final_filename}")

        return {
            "file_id": file_id,
            "filename": file.filename,
            "path": str(file_path),
            "size": file_size,
            "mime_type": detected_mime
        }

    except HTTPException:
        raise
    except Exception as e:
        if temp_file and os.path.exists(temp_file.name):
            os.unlink(temp_file.name)
        logger.error(f"Errore upload: {e}")
        raise HTTPException(status_code=500, detail=f"Errore upload: {str(e)}")

@app.post("/api/process")
async def process_video(
    background_tasks: BackgroundTasks,
    foreground_file_id: str = Form(...),
    background_file_id: str = Form(...),
    start_time: float = Form(0.0),
    duration: Optional[float] = Form(None),
    audio_mode: str = Form("synced"),
    cta_x_pos: int = Form(0),
    cta_y_pos: int = Form(0),
    cta_scale: float = Form(1.0),
    opacity: float = Form(1.0),
    fast_mode: bool = Form(True),
    gpu_mode: bool = Form(False),
    logo_file_id: Optional[str] = Form(None),
    logo_x_pos: Optional[int] = Form(None),
    logo_y_pos: Optional[int] = Form(None),
    logo_scale: Optional[float] = Form(None)
):
    # Controllo concorrenza
    active_jobs = get_active_jobs_count()
    if active_jobs >= MAX_CONCURRENT_JOBS:
        raise HTTPException(
            status_code=429,
            detail=f"Troppi job in elaborazione. Max concorrenti: {MAX_CONCURRENT_JOBS}"
        )

    # Validazione parametri con Pydantic
    try:
        params = ProcessVideoRequest(
            foreground_file_id=foreground_file_id,
            background_file_id=background_file_id,
            start_time=start_time,
            duration=duration,
            audio_mode=audio_mode,
            cta_x_pos=cta_x_pos,
            cta_y_pos=cta_y_pos,
            cta_scale=cta_scale,
            opacity=opacity,
            fast_mode=fast_mode,
            gpu_mode=gpu_mode,
            logo_file_id=logo_file_id,
            logo_x_pos=logo_x_pos,
            logo_y_pos=logo_y_pos,
            logo_scale=logo_scale
        )
    except Exception as e:
        raise HTTPException(status_code=422, detail=f"Validazione fallita: {str(e)}")

    job_id = str(uuid.uuid4())
    job = ProcessingJob(job_id)

    with jobs_lock:
        processing_jobs[job_id] = job

    save_jobs_state()

    logger.info(f"Nuovo job creato: {job_id} (attivi: {active_jobs + 1}/{MAX_CONCURRENT_JOBS})")

    background_tasks.add_task(
        process_video_task,
        job,
        params.foreground_file_id,
        params.background_file_id,
        params.start_time,
        params.duration,
        params.audio_mode,
        params.cta_x_pos,
        params.cta_y_pos,
        params.cta_scale,
        params.opacity,
        params.fast_mode,
        params.gpu_mode,
        params.logo_file_id,
        params.logo_x_pos,
        params.logo_y_pos,
        params.logo_scale
    )

    return {"job_id": job_id}

async def process_video_task(
    job: ProcessingJob,
    foreground_file_id: str,
    background_file_id: str,
    start_time: float,
    duration: Optional[float],
    audio_mode: str,
    cta_x_pos: int,
    cta_y_pos: int,
    cta_scale: float,
    opacity: float,
    fast_mode: bool,
    gpu_mode: bool,
    logo_file_id: Optional[str] = None,
    logo_x_pos: Optional[int] = None,
    logo_y_pos: Optional[int] = None,
    logo_scale: Optional[float] = None
):
    try:
        job.update(status="processing", message="Elaborazione video in corso...", progress=10)
        save_jobs_state()
        
        
        # Find uploaded files with type validation
        foreground_path = None
        background_path = None
        logo_path = None
        
        # Video extensions for foreground and background
        video_extensions = ['.mp4', '.avi', '.mov', '.mkv', '.webm']
        image_extensions = ['.png', '.jpg', '.jpeg', '.gif', '.svg', '.webp']
        
        # Find foreground video file
        for file_path in UPLOAD_DIR.glob(f"{foreground_file_id}.*"):
            if file_path.suffix.lower() in video_extensions:
                foreground_path = file_path
                break
            
        # Find background video file  
        for file_path in UPLOAD_DIR.glob(f"{background_file_id}.*"):
            if file_path.suffix.lower() in video_extensions:
                background_path = file_path
                break
            
        # Find logo file (can be image)
        if logo_file_id:
            for file_path in UPLOAD_DIR.glob(f"{logo_file_id}.*"):
                if file_path.suffix.lower() in image_extensions:
                    logo_path = file_path
                    break
            
        # Detailed error messages
        if not foreground_path:
            raise Exception(f"File video CTA non trovato per ID: {foreground_file_id}. Assicurati di aver caricato un file video (.mp4, .avi, .mov, .mkv).")
        if not background_path:
            raise Exception(f"File video di sfondo non trovato per ID: {background_file_id}. Assicurati di aver caricato un file video (.mp4, .avi, .mov, .mkv).")
            
        # Output path
        output_path = OUTPUT_DIR / f"{job.job_id}_output.mp4"

        job.update(progress=30, message="Esecuzione chromakey...")
        save_jobs_state()
        
        # Setup chromakey parameters
        lower_green = np.array([40, 40, 40])
        upper_green = np.array([80, 255, 255])
        
        # Progress callback function (thread-safe)
        def update_progress(progress):
            try:
                # Check if job should be stopped
                if job.should_stop:
                    logger.info(f"Job {job.job_id} interrotto per richiesta cancellazione")
                    return False  # Signal to stop processing

                # If progress is None, just check cancellation status
                if progress is None:
                    return True

                # Thread-safe update
                job.update(
                    progress=int(progress),
                    message=f"Elaborazione video... {progress}%"
                )

                # Salva stato ogni 10% di progresso
                if int(progress) % 10 == 0:
                    save_jobs_state()

                return True  # Signal to continue processing
            except Exception as e:
                logger.error(f"Errore in progress callback: {e}")
                return True
        
        # Call chromakey function with logo support
        success = remove_background_and_overlay_timed(
            str(foreground_path),
            str(background_path), 
            str(output_path),
            start_time=start_time,
            duration=duration if duration and duration > 0 else None,
            lower_green=lower_green,
            upper_green=upper_green,
            blur_kernel=5,
            audio_source=audio_mode,
            position=(cta_x_pos, cta_y_pos),
            scale=cta_scale,
            opacity=opacity,
            fast_mode=fast_mode,
            gpu_accel=gpu_mode,
            logo_path=str(logo_path) if logo_path else None,
            logo_position=(logo_x_pos, logo_y_pos) if logo_x_pos is not None and logo_y_pos is not None else None,
            logo_scale=logo_scale,
            progress_callback=update_progress
        )
        
        if success:
            output_file = f"/outputs/{job.job_id}_output.mp4" if output_path.exists() else None
            job.update(
                status="completed",
                progress=100,
                message="Video elaborato con successo!",
                output_file=output_file
            )
            logger.info(f"Job {job.job_id} completato con successo")
        else:
            raise Exception("Errore durante l'elaborazione chromakey")

    except Exception as e:
        logger.error(f"Job {job.job_id} fallito: {e}")
        job.update(
            status="error",
            error=str(e),
            message=f"Errore: {e}"
        )
    finally:
        save_jobs_state()

@app.post("/api/workflow-auto")
async def workflow_automatico(
    background_tasks: BackgroundTasks,
    video_file_id: str = Form(...),
    logo_overlay: bool = Form(False),
    call_to_action: bool = Form(False),
    video_transcription: bool = Form(False),
    audio_translation: bool = Form(False),
    cover_generation: bool = Form(False),
    metadata_generation: bool = Form(False),
    youtube_upload: bool = Form(False),
    cta_file_id: Optional[str] = Form(None),
    logo_file_id: Optional[str] = Form(None),
    cta_x_pos: int = Form(0),
    cta_y_pos: int = Form(0),
    cta_scale: float = Form(1.0),
    logo_x_pos: int = Form(0),
    logo_y_pos: int = Form(0),
    logo_scale: float = Form(1.0),
    target_language: Optional[str] = Form(None)
):
    """
    Workflow automatico che esegue tutte le operazioni selezionate in sequenza.
    """
    # Verifica che almeno una funzionalit√† sia attiva
    if not any([logo_overlay, call_to_action, video_transcription, audio_translation,
                cover_generation, metadata_generation, youtube_upload]):
        raise HTTPException(
            status_code=400,
            detail="Seleziona almeno una funzionalit√† da eseguire"
        )

    job_id = str(uuid.uuid4())
    job = ProcessingJob(job_id)

    with jobs_lock:
        processing_jobs[job_id] = job

    save_jobs_state()

    logger.info(f"Workflow automatico avviato: {job_id}")

    background_tasks.add_task(
        execute_workflow_task,
        job,
        video_file_id,
        logo_overlay,
        call_to_action,
        video_transcription,
        audio_translation,
        cover_generation,
        metadata_generation,
        youtube_upload,
        cta_file_id,
        logo_file_id,
        cta_x_pos,
        cta_y_pos,
        cta_scale,
        logo_x_pos,
        logo_y_pos,
        logo_scale,
        target_language
    )

    return {"job_id": job_id, "message": "Workflow automatico avviato"}

async def execute_workflow_task(
    job: ProcessingJob,
    video_file_id: str,
    logo_overlay: bool,
    call_to_action: bool,
    video_transcription: bool,
    audio_translation: bool,
    cover_generation: bool,
    metadata_generation: bool,
    youtube_upload: bool,
    cta_file_id: Optional[str],
    logo_file_id: Optional[str],
    cta_x_pos: int,
    cta_y_pos: int,
    cta_scale: float,
    logo_x_pos: int,
    logo_y_pos: int,
    logo_scale: float,
    target_language: Optional[str]
):
    """
    Esegue il workflow automatico in background.
    """
    try:
        job.update(status="processing", message="Inizio workflow automatico...", progress=0)
        save_jobs_state()

        # Trova il file video principale
        video_path = None
        video_extensions = ['.mp4', '.avi', '.mov', '.mkv', '.webm']

        for file_path in UPLOAD_DIR.glob(f"{video_file_id}.*"):
            if file_path.suffix.lower() in video_extensions:
                video_path = file_path
                break

        if not video_path:
            raise Exception(f"Video non trovato per ID: {video_file_id}")

        current_video = video_path
        steps_total = sum([logo_overlay, call_to_action, video_transcription, audio_translation,
                          cover_generation, metadata_generation, youtube_upload])
        step_current = 0
        transcription_text = None
        metadata_result = None

        # Step 1: Logo Overlay
        if logo_overlay and logo_file_id:
            step_current += 1
            progress = int((step_current / steps_total) * 90)
            job.update(progress=progress, message=f"Step {step_current}/{steps_total}: Applicazione logo...")
            save_jobs_state()

            # Trova logo
            logo_path = None
            image_extensions = ['.png', '.jpg', '.jpeg', '.gif', '.svg', '.webp']
            for file_path in UPLOAD_DIR.glob(f"{logo_file_id}.*"):
                if file_path.suffix.lower() in image_extensions:
                    logo_path = file_path
                    break

            if logo_path:
                # Applica logo usando ffmpeg
                output_with_logo = OUTPUT_DIR / f"{job.job_id}_with_logo.mp4"
                cmd = [
                    'ffmpeg', '-i', str(current_video),
                    '-i', str(logo_path),
                    '-filter_complex',
                    f'[1:v]scale=iw*{logo_scale}:ih*{logo_scale}[logo];[0:v][logo]overlay={logo_x_pos}:{logo_y_pos}',
                    '-codec:a', 'copy',
                    str(output_with_logo)
                ]
                result = subprocess.run(cmd, capture_output=True, text=True)
                if result.returncode == 0 and output_with_logo.exists():
                    current_video = output_with_logo
                    logger.info(f"Logo applicato: {current_video}")

        # Step 2: Call to Action Overlay
        if call_to_action and cta_file_id:
            step_current += 1
            progress = int((step_current / steps_total) * 90)
            job.update(progress=progress, message=f"Step {step_current}/{steps_total}: Applicazione CTA...")
            save_jobs_state()

            # Trova CTA video
            cta_path = None
            for file_path in UPLOAD_DIR.glob(f"{cta_file_id}.*"):
                if file_path.suffix.lower() in video_extensions:
                    cta_path = file_path
                    break

            if cta_path:
                # Applica chromakey CTA
                output_with_cta = OUTPUT_DIR / f"{job.job_id}_with_cta.mp4"

                lower_green = np.array([40, 40, 40])
                upper_green = np.array([80, 255, 255])

                success = remove_background_and_overlay_timed(
                    str(cta_path),
                    str(current_video),
                    str(output_with_cta),
                    start_time=0,
                    duration=None,
                    lower_green=lower_green,
                    upper_green=upper_green,
                    blur_kernel=5,
                    audio_source="background",
                    position=(cta_x_pos, cta_y_pos),
                    scale=cta_scale,
                    opacity=1.0,
                    fast_mode=True,
                    gpu_accel=False,
                    progress_callback=None
                )

                if success and output_with_cta.exists():
                    current_video = output_with_cta
                    logger.info(f"CTA applicato: {current_video}")

        # Step 3: Trascrizione Video
        if video_transcription:
            step_current += 1
            progress = int((step_current / steps_total) * 90)
            job.update(progress=progress, message=f"Step {step_current}/{steps_total}: Trascrizione video...")
            save_jobs_state()

            try:
                # Estrai audio dal video
                audio_path = OUTPUT_DIR / f"{job.job_id}_audio.mp3"
                cmd = ['ffmpeg', '-i', str(current_video), '-q:a', '0', '-map', 'a', str(audio_path)]
                subprocess.run(cmd, capture_output=True, check=True)

                if audio_path.exists():
                    # Usa Whisper per trascrivere (assumendo che sia configurato)
                    import whisper
                    model = whisper.load_model("base")
                    result = model.transcribe(str(audio_path))
                    transcription_text = result["text"]

                    # Salva trascrizione
                    transcription_file = OUTPUT_DIR / f"{job.job_id}_transcription.txt"
                    with open(transcription_file, 'w', encoding='utf-8') as f:
                        f.write(transcription_text)

                    logger.info(f"Trascrizione completata: {len(transcription_text)} caratteri")
            except Exception as e:
                logger.error(f"Errore trascrizione: {e}")

        # Step 4: Traduzione Audio
        if audio_translation and target_language:
            step_current += 1
            progress = int((step_current / steps_total) * 90)
            job.update(progress=progress, message=f"Step {step_current}/{steps_total}: Traduzione audio...")
            save_jobs_state()

            # Implementazione traduzione (richiede VideoTranslator configurato)
            try:
                translator = VideoTranslator()
                output_translated = OUTPUT_DIR / f"{job.job_id}_translated.mp4"

                # Questa √® una semplificazione - la traduzione vera richiede pi√π parametri
                # Per ora logghiamo che la feature √® attiva
                logger.info(f"Traduzione richiesta verso: {target_language}")
            except Exception as e:
                logger.error(f"Errore traduzione: {e}")

        # Step 5: Generazione Copertina
        if cover_generation:
            step_current += 1
            progress = int((step_current / steps_total) * 90)
            job.update(progress=progress, message=f"Step {step_current}/{steps_total}: Generazione copertina...")
            save_jobs_state()

            try:
                # Estrai frame dal video
                cover_path = OUTPUT_DIR / f"{job.job_id}_cover.jpg"
                cmd = [
                    'ffmpeg', '-i', str(current_video),
                    '-ss', '00:00:01',
                    '-vframes', '1',
                    str(cover_path)
                ]
                result = subprocess.run(cmd, capture_output=True)
                if result.returncode == 0 and cover_path.exists():
                    logger.info(f"Copertina generata: {cover_path}")
            except Exception as e:
                logger.error(f"Errore generazione copertina: {e}")

        # Step 6: Generazione Metadati
        if metadata_generation and transcription_text:
            step_current += 1
            progress = int((step_current / steps_total) * 90)
            job.update(progress=progress, message=f"Step {step_current}/{steps_total}: Generazione metadati...")
            save_jobs_state()

            try:
                metadata_result = generate_metadata_from_transcription(transcription_text)

                # Salva metadati
                metadata_file = OUTPUT_DIR / f"{job.job_id}_metadata.json"
                with open(metadata_file, 'w', encoding='utf-8') as f:
                    json.dump(metadata_result, f, ensure_ascii=False, indent=2)

                logger.info(f"Metadati generati e salvati")
            except Exception as e:
                logger.error(f"Errore generazione metadati: {e}")

        # Step 7: Upload YouTube
        if youtube_upload and metadata_result:
            step_current += 1
            progress = int((step_current / steps_total) * 90)
            job.update(progress=progress, message=f"Step {step_current}/{steps_total}: Upload YouTube...")
            save_jobs_state()

            try:
                uploader = YouTubeUploader()
                # Questa √® una semplificazione - l'upload richiede autenticazione OAuth
                logger.info(f"Upload YouTube richiesto per video: {current_video}")
            except Exception as e:
                logger.error(f"Errore upload YouTube: {e}")

        # Workflow completato
        output_file = f"/outputs/{current_video.name}"
        job.update(
            status="completed",
            progress=100,
            message="Workflow automatico completato!",
            output_file=output_file
        )
        logger.info(f"Workflow {job.job_id} completato con successo")

    except Exception as e:
        logger.error(f"Workflow {job.job_id} fallito: {e}")
        job.update(
            status="error",
            error=str(e),
            message=f"Errore workflow: {e}"
        )
    finally:
        save_jobs_state()

@app.get("/api/download/{job_id}")
async def download_result(job_id: str):
    if job_id not in processing_jobs:
        raise HTTPException(status_code=404, detail="Job non trovato")
    
    job = processing_jobs[job_id]
    if job.status != "completed" or not job.output_file:
        raise HTTPException(status_code=400, detail="Video non pronto")
    
    output_path = OUTPUT_DIR / f"{job_id}_output.mp4"
    if not output_path.exists():
        raise HTTPException(status_code=404, detail="File non trovato")
    
    return FileResponse(
        path=output_path,
        filename=f"video_processed_{job_id}.mp4",
        media_type="video/mp4"
    )

@app.delete("/api/jobs/{job_id}")
async def delete_job(job_id: str):
    with jobs_lock:
        if job_id not in processing_jobs:
            return {"message": "Job non trovato"}

        job = processing_jobs[job_id]

    logger.info(f"Richiesta cancellazione job {job_id}, status: {job.status}")

    # If job is already completed, don't delete the output file
    if job.status == "completed":
        logger.info(f"Job {job_id} gi√† completato - mantengo output file")
        with jobs_lock:
            del processing_jobs[job_id]
        save_jobs_state()
        return {"message": "Job rimosso (era gi√† completato)"}

    # Set stop flag to interrupt processing if still running
    job.should_stop = True
    job.update(status="cancelled", message="Elaborazione interrotta dall'utente")

    logger.info(f"Job {job_id} marcato per cancellazione")

    # Give some time for the processing to stop gracefully
    await asyncio.sleep(0.5)

    # Clean up files only if job was not completed
    for file_path in UPLOAD_DIR.glob(f"{job_id}*"):
        file_path.unlink(missing_ok=True)

    output_path = OUTPUT_DIR / f"{job_id}_output.mp4"
    if output_path.exists():
        logger.info(f"Rimozione output incompleto: {output_path}")
        output_path.unlink(missing_ok=True)

    # Remove from jobs list
    with jobs_lock:
        del processing_jobs[job_id]

    save_jobs_state()

    return {"message": "Job cancellato e interrotto"}

@app.delete("/api/delete/{filename}")
async def delete_file(filename: str):
    """Elimina un singolo file dalla cartella uploads"""
    try:
        # Sanitizza il nome file per sicurezza
        safe_filename = Path(filename).name
        file_path = UPLOAD_DIR / safe_filename

        if not file_path.exists():
            raise HTTPException(status_code=404, detail="File non trovato")

        # Verifica che sia effettivamente nella cartella uploads
        if not file_path.is_relative_to(UPLOAD_DIR):
            raise HTTPException(status_code=403, detail="Accesso negato")

        file_path.unlink()
        logger.info(f"File eliminato: {safe_filename}")

        return {"message": "File eliminato con successo", "filename": safe_filename}

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Errore eliminazione file {filename}: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.delete("/api/delete-all-recordings")
async def delete_all_recordings():
    """Elimina tutte le registrazioni (file che iniziano con 'recording_')"""
    try:
        deleted_count = 0

        for file_path in UPLOAD_DIR.glob("recording_*"):
            if file_path.is_file():
                file_path.unlink()
                deleted_count += 1
                logger.info(f"Registrazione eliminata: {file_path.name}")

        logger.info(f"Totale registrazioni eliminate: {deleted_count}")

        return {
            "message": f"{deleted_count} registrazioni eliminate",
            "deleted": deleted_count
        }

    except Exception as e:
        logger.error(f"Errore eliminazione registrazioni: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/files")
async def get_files():
    """Get list of all files with metadata"""
    try:
        files = []
        stats = {
            "videos": 0,
            "images": 0,
            "processed": 0,
            "totalSize": 0
        }
        
        # File di sistema da escludere
        system_files = {'.DS_Store', 'Thumbs.db', 'desktop.ini', '.gitkeep', '.gitignore'}

        # Scan uploads directory
        for file_path in UPLOAD_DIR.glob("*"):
            if file_path.is_file() and file_path.name not in system_files:
                file_info = get_file_info(file_path, "uploads")
                files.append(file_info)
                
                if file_info["type"] == "video":
                    stats["videos"] += 1
                elif file_info["type"] == "image":
                    stats["images"] += 1
                elif file_info["type"] == "audio":
                    stats["audio"] = stats.get("audio", 0) + 1
                elif file_info["type"] == "subtitle":
                    stats["subtitles"] = stats.get("subtitles", 0) + 1
                
                stats["totalSize"] += file_info["size"]
        
        # Scan outputs directory
        for file_path in OUTPUT_DIR.glob("*"):
            if file_path.is_file() and file_path.name not in system_files:
                file_info = get_file_info(file_path, "outputs")
                files.append(file_info)
                stats["processed"] += 1
                stats["totalSize"] += file_info["size"]
        
        # Sort files by modification time (newest first)
        files.sort(key=lambda x: x["modified"], reverse=True)
        
        return {
            "files": files,
            "stats": stats
        }
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Errore nel caricamento dei file: {str(e)}")

def get_file_info(file_path: Path, directory: str):
    """Get detailed file information including metadata"""
    stat = file_path.stat()
    
    # Basic info
    file_info = {
        "name": file_path.name,
        "path": f"/{directory}/{file_path.name}",
        "size": stat.st_size,
        "modified": stat.st_mtime,
        "directory": directory
    }
    
    # Determine detailed file type and get metadata
    suffix = file_path.suffix.lower()
    
    if suffix in ['.mp4', '.avi', '.mov', '.mkv', '.webm', '.flv']:
        file_info["type"] = "video"
        file_info["category"] = "Video"
        file_info["metadata"] = get_video_metadata(file_path)
    elif suffix in ['.png', '.jpg', '.jpeg', '.gif', '.svg', '.webp', '.bmp']:
        file_info["type"] = "image"
        file_info["category"] = "Immagine"
        file_info["metadata"] = get_image_metadata(file_path)
    elif suffix in ['.srt', '.vtt', '.ass', '.ssa']:
        file_info["type"] = "subtitle"
        file_info["category"] = "Sottotitoli"
        file_info["metadata"] = get_subtitle_metadata(file_path)
    elif suffix in ['.mp3', '.wav', '.aac', '.ogg', '.flac']:
        file_info["type"] = "audio"
        file_info["category"] = "Audio"
        file_info["metadata"] = get_audio_metadata(file_path)
    elif suffix in ['.txt', '.log']:
        file_info["type"] = "text"
        file_info["category"] = "Testo"
        file_info["metadata"] = {"lines": count_file_lines(file_path)}
    else:
        file_info["type"] = "other"
        file_info["category"] = "Altro"
        file_info["metadata"] = {}
        
    return file_info

def get_video_metadata(file_path: Path):
    """Get video metadata using ffprobe"""
    try:
        cmd = [
            'ffprobe', '-v', 'quiet', '-print_format', 'json', '-show_format', '-show_streams',
            str(file_path)
        ]
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
        
        if result.returncode == 0:
            data = json.loads(result.stdout)
            
            # Find video stream
            video_stream = next((s for s in data.get('streams', []) if s.get('codec_type') == 'video'), None)
            format_info = data.get('format', {})
            
            metadata = {}
            
            if video_stream:
                metadata['width'] = video_stream.get('width', 0)
                metadata['height'] = video_stream.get('height', 0)
                metadata['codec'] = video_stream.get('codec_name', 'Unknown')
                
                # Calculate duration
                duration = float(format_info.get('duration', 0))
                metadata['duration'] = duration
                metadata['duration_formatted'] = format_duration(duration)
                
            # Bitrate
            bitrate = format_info.get('bit_rate')
            if bitrate:
                metadata['bitrate'] = f"{int(bitrate) // 1000} kbps"
                
            return metadata
            
    except Exception as e:
        print(f"Error getting video metadata for {file_path}: {e}")
    
    return {}

def get_image_metadata(file_path: Path):
    """Get basic image metadata"""
    try:
        # Try to get image dimensions using PIL if available
        from PIL import Image
        with Image.open(file_path) as img:
            return {
                'width': img.width,
                'height': img.height,
                'mode': img.mode
            }
    except ImportError:
        # PIL not available, return basic info
        return {}
    except Exception as e:
        print(f"Error getting image metadata for {file_path}: {e}")
        return {}

def get_subtitle_metadata(file_path: Path):
    """Get subtitle file metadata"""
    try:
        lines = count_file_lines(file_path)
        
        # Try to detect subtitle format
        format_type = "Unknown"
        if file_path.suffix.lower() == '.srt':
            format_type = "SubRip"
        elif file_path.suffix.lower() == '.vtt':
            format_type = "WebVTT"
        elif file_path.suffix.lower() in ['.ass', '.ssa']:
            format_type = "Advanced SSA"
            
        return {
            'format': format_type,
            'lines': lines
        }
    except Exception:
        return {}

def get_audio_metadata(file_path: Path):
    """Get audio metadata using ffprobe"""
    try:
        cmd = [
            'ffprobe', '-v', 'quiet', '-print_format', 'json', '-show_format', '-show_streams',
            str(file_path)
        ]
        result = subprocess.run(cmd, capture_output=True, text=True, timeout=10)
        
        if result.returncode == 0:
            data = json.loads(result.stdout)
            audio_stream = next((s for s in data.get('streams', []) if s.get('codec_type') == 'audio'), None)
            format_info = data.get('format', {})
            
            metadata = {}
            
            if audio_stream:
                metadata['codec'] = audio_stream.get('codec_name', 'Unknown')
                metadata['sample_rate'] = audio_stream.get('sample_rate', 0)
                metadata['channels'] = audio_stream.get('channels', 0)
                
            # Duration
            duration = float(format_info.get('duration', 0))
            if duration > 0:
                metadata['duration'] = duration
                metadata['duration_formatted'] = format_duration(duration)
                
            return metadata
            
    except Exception as e:
        print(f"Error getting audio metadata for {file_path}: {e}")
    
    return {}

def count_file_lines(file_path: Path):
    """Count lines in a text file"""
    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            return sum(1 for _ in f)
    except Exception:
        return 0

def format_duration(seconds):
    """Format duration in seconds to HH:MM:SS"""
    if seconds <= 0:
        return "00:00"
        
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    
    if hours > 0:
        return f"{hours:02d}:{minutes:02d}:{secs:02d}"
    else:
        return f"{minutes:02d}:{secs:02d}"

@app.post("/api/files/delete")
async def delete_file(request: Request):
    """Delete a single file"""
    try:
        data = await request.json()
        file_path = data.get("path")
        
        if not file_path:
            raise HTTPException(status_code=400, detail="Path del file richiesto")
        
        # Convert relative path to absolute
        if file_path.startswith("/uploads/"):
            full_path = UPLOAD_DIR / file_path.replace("/uploads/", "")
        elif file_path.startswith("/outputs/"):
            full_path = OUTPUT_DIR / file_path.replace("/outputs/", "")
        else:
            raise HTTPException(status_code=400, detail="Path del file non valido")
        
        if full_path.exists():
            full_path.unlink()
            return {"message": "File eliminato con successo"}
        else:
            raise HTTPException(status_code=404, detail="File non trovato")
            
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Errore nell'eliminazione: {str(e)}")

@app.post("/api/files/delete-all")
async def delete_all_files():
    """Delete all files from uploads and outputs directories"""
    try:
        deleted_count = 0
        
        # Delete all files in uploads directory
        for file_path in UPLOAD_DIR.glob("*"):
            if file_path.is_file():
                file_path.unlink()
                deleted_count += 1
        
        # Delete all files in outputs directory
        for file_path in OUTPUT_DIR.glob("*"):
            if file_path.is_file():
                file_path.unlink()
                deleted_count += 1
        
        # Clear processing jobs
        processing_jobs.clear()
        
        return {"message": f"Eliminati {deleted_count} file", "count": deleted_count}
        
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Errore nell'eliminazione: {str(e)}")

@app.get("/api/file-info")
async def get_file_info_endpoint(path: str):
    """Get detailed information about a specific file"""
    try:
        if not path:
            raise HTTPException(status_code=400, detail="Path del file richiesto")

        # Convert relative path to absolute
        if path.startswith("/uploads/"):
            full_path = UPLOAD_DIR / path.replace("/uploads/", "")
            directory = "uploads"
        elif path.startswith("/outputs/"):
            full_path = OUTPUT_DIR / path.replace("/outputs/", "")
            directory = "outputs"
        else:
            raise HTTPException(status_code=400, detail="Path del file non valido")

        if not full_path.exists():
            raise HTTPException(status_code=404, detail="File non trovato")

        # Use existing get_file_info function
        file_info = get_file_info(full_path, directory)
        return file_info

    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Errore nel recupero info file: {str(e)}")

# ========== SCREEN RECORDING API ==========

@app.get("/api/screen/info")
async def get_screen_information():
    """Ottieni informazioni schermi disponibili"""
    try:
        info = get_screen_info()
        return info
    except Exception as e:
        logger.error(f"Errore get screen info: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/screen/windows")
async def get_windows_list():
    """Elenca finestre disponibili per cattura"""
    try:
        windows = get_available_windows()
        return {"windows": windows}
    except Exception as e:
        logger.error(f"Errore get windows: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/screen/start")
async def start_screen_recording(
    background_tasks: BackgroundTasks,
    fps: int = Form(30),
    audio_source: str = Form("system"),
    region_x: int = Form(None),
    region_y: int = Form(None),
    region_width: int = Form(None),
    region_height: int = Form(None)
):
    """
    Avvia registrazione schermo

    Args:
        fps: Frame per secondo (15-60)
        audio_source: "system", "microphone", "none"
        region_*: Opzionale per catturare solo una regione
    """
    try:
        # Validazione FPS
        if fps < 15 or fps > 60:
            raise HTTPException(status_code=400, detail="FPS deve essere tra 15 e 60")

        # Genera ID recording
        recording_id = str(uuid.uuid4())
        output_path = OUTPUT_DIR / f"recording_{recording_id}.mp4"

        # Determina regione
        region = None
        if all(v is not None for v in [region_x, region_y, region_width, region_height]):
            region = (region_x, region_y, region_width, region_height)
            logger.info(f"Recording regione: {region}")

        # Crea recorder
        recorder = ScreenRecorder(
            output_path=str(output_path),
            fps=fps,
            audio_source=audio_source
        )

        # Avvia recording in background
        success = recorder.start_recording(region=region)

        if not success:
            raise HTTPException(status_code=500, detail="Impossibile avviare recording")

        # Salva recorder attivo
        with recorders_lock:
            active_recorders[recording_id] = {
                'recorder': recorder,
                'started_at': datetime.now(),
                'fps': fps,
                'audio': audio_source,
                'output': str(output_path)
            }

        logger.info(f"Recording avviato: {recording_id}")

        return {
            "recording_id": recording_id,
            "status": "recording",
            "output_path": f"/outputs/recording_{recording_id}.mp4"
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Errore start recording: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.post("/api/screen/stop/{recording_id}")
async def stop_screen_recording(recording_id: str):
    """Ferma registrazione schermo"""
    try:
        with recorders_lock:
            if recording_id not in active_recorders:
                raise HTTPException(status_code=404, detail="Recording non trovato")

            recorder_data = active_recorders[recording_id]
            recorder = recorder_data['recorder']

        logger.info(f"Stopping recording: {recording_id}")

        # Ferma recording (pu√≤ richiedere qualche secondo)
        success = recorder.stop_recording()

        if not success:
            raise HTTPException(status_code=500, detail="Errore durante stop recording")

        # Rimuovi da attivi
        with recorders_lock:
            duration = (datetime.now() - recorder_data['started_at']).total_seconds()
            output_path = recorder_data['output']
            del active_recorders[recording_id]

        logger.info(f"Recording completato: {recording_id} ({duration:.1f}s)")

        return {
            "recording_id": recording_id,
            "status": "completed",
            "duration": duration,
            "output_path": f"/outputs/recording_{recording_id}.mp4",
            "download_url": f"/api/screen/download/{recording_id}"
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Errore stop recording: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/screen/status")
async def get_recording_status():
    """Status di tutti i recording attivi"""
    try:
        with recorders_lock:
            active = []
            for rec_id, data in active_recorders.items():
                duration = (datetime.now() - data['started_at']).total_seconds()
                active.append({
                    'recording_id': rec_id,
                    'duration': duration,
                    'fps': data['fps'],
                    'audio': data['audio']
                })

        return {
            "active_recordings": len(active),
            "recordings": active
        }

    except Exception as e:
        logger.error(f"Errore get status: {e}")
        raise HTTPException(status_code=500, detail=str(e))

@app.get("/api/screen/download/{recording_id}")
async def download_recording(recording_id: str):
    """Download file recording"""
    try:
        output_path = OUTPUT_DIR / f"recording_{recording_id}.mp4"

        if not output_path.exists():
            raise HTTPException(status_code=404, detail="Recording non trovato")

        return FileResponse(
            path=output_path,
            filename=f"screen_recording_{recording_id}.mp4",
            media_type="video/mp4"
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Errore download: {e}")
        raise HTTPException(status_code=500, detail=str(e))

# ========== WEB VIDEO DOWNLOAD API ==========

@app.post("/api/download-web-video")
async def download_web_video(url: str = Form(...)):
    """
    Scarica video da URL web (YouTube, Vimeo, link diretti)
    """
    try:
        logger.info(f"Download richiesto per URL: {url}")

        # Genera ID univoco per il download
        download_id = str(uuid.uuid4())
        output_filename = f"web_video_{download_id}.mp4"
        output_path = UPLOAD_DIR / output_filename

        # Controlla se √® un link diretto a file video
        video_extensions = ['.mp4', '.avi', '.mov', '.mkv', '.webm', '.flv', '.m4v']
        is_direct_link = any(url.lower().endswith(ext) for ext in video_extensions)

        if is_direct_link:
            # Download diretto con subprocess e curl/wget
            logger.info("Link diretto rilevato, uso curl per download")

            # Prova con curl
            try:
                result = subprocess.run(
                    ['curl', '-L', '-o', str(output_path), url],
                    capture_output=True,
                    timeout=300,  # 5 minuti timeout
                    check=True
                )
                logger.info(f"Download completato con curl: {output_filename}")
            except (subprocess.CalledProcessError, FileNotFoundError):
                # Fallback a wget se curl non disponibile
                logger.info("Curl fallito, provo con wget")
                result = subprocess.run(
                    ['wget', '-O', str(output_path), url],
                    capture_output=True,
                    timeout=300,
                    check=True
                )
                logger.info(f"Download completato con wget: {output_filename}")
        else:
            # Usa yt-dlp per YouTube/Vimeo e altri servizi
            logger.info("URL non diretto, uso yt-dlp")

            # Comando yt-dlp
            cmd = [
                'yt-dlp',
                '-f', 'bestvideo[ext=mp4]+bestaudio[ext=m4a]/best[ext=mp4]/best',
                '--merge-output-format', 'mp4',
                '-o', str(output_path),
                url
            ]

            result = subprocess.run(
                cmd,
                capture_output=True,
                text=True,
                timeout=600,  # 10 minuti timeout per video grandi
                check=True
            )

            logger.info(f"Download completato con yt-dlp: {output_filename}")

        # Verifica che il file esista e abbia dimensione valida
        if not output_path.exists():
            raise Exception("File non creato dopo download")

        file_size = output_path.stat().st_size
        if file_size < 1024:  # Meno di 1KB = errore
            output_path.unlink()
            raise Exception("File scaricato troppo piccolo, probabilmente errore")

        logger.info(f"Download completato: {output_filename} ({file_size / 1024 / 1024:.2f}MB)")

        return {
            "success": True,
            "file_id": download_id,
            "filename": output_filename,
            "path": f"/uploads/{output_filename}",
            "size": file_size,
            "message": "Video scaricato con successo"
        }

    except subprocess.TimeoutExpired:
        logger.error("Timeout durante download video")
        raise HTTPException(status_code=408, detail="Timeout: il download ha impiegato troppo tempo")
    except subprocess.CalledProcessError as e:
        logger.error(f"Errore processo download: {e.stderr if hasattr(e, 'stderr') else str(e)}")
        raise HTTPException(
            status_code=400,
            detail=f"Errore download video: {e.stderr.decode() if hasattr(e, 'stderr') else str(e)}"
        )
    except Exception as e:
        logger.error(f"Errore download web video: {e}")
        # Cleanup file parziale se esiste
        if output_path.exists():
            output_path.unlink()
        raise HTTPException(status_code=500, detail=f"Errore: {str(e)}")

@app.post("/api/transcribe-video")
async def transcribe_video(file_id: str = Form(...)):
    """
    Trascrivi un video e genera file SRT (sottotitoli YouTube) e TXT
    """
    try:
        logger.info(f"Trascrizione richiesta per file_id: {file_id}")

        # Trova il file video
        video_path = None
        video_extensions = ['.mp4', '.avi', '.mov', '.mkv', '.webm', '.m4v']

        for ext in video_extensions:
            test_path = UPLOAD_DIR / f"{file_id}{ext}"
            if test_path.exists():
                video_path = test_path
                break

        # Se non trovato con solo ID, prova con prefisso web_video_
        if not video_path:
            for ext in video_extensions:
                test_path = UPLOAD_DIR / f"web_video_{file_id}{ext}"
                if test_path.exists():
                    video_path = test_path
                    break

        if not video_path or not video_path.exists():
            raise Exception(f"Video non trovato per file_id: {file_id}")

        logger.info(f"Video trovato: {video_path}")

        # Estrai audio dal video
        audio_id = str(uuid.uuid4())
        audio_path = UPLOAD_DIR / f"temp_audio_{audio_id}.wav"

        logger.info("Estrazione audio dal video...")
        subprocess.run(
            ['ffmpeg', '-i', str(video_path), '-vn', '-acodec', 'pcm_s16le', '-ar', '16000', '-ac', '1', str(audio_path)],
            capture_output=True,
            check=True
        )

        # Trascrivi l'audio usando Whisper
        logger.info("Avvio trascrizione con Whisper...")

        import whisper

        # Carica il modello Whisper (usa "base" per velocit√†, "medium" o "large" per accuratezza)
        model = whisper.load_model("base")

        # Trascrivi
        result = model.transcribe(str(audio_path), language="it")

        # Genera nome file basato sul video originale
        video_basename = video_path.stem
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")

        # Salva trascrizione TXT
        txt_filename = f"trascrizione_{video_basename}_{timestamp}.txt"
        txt_path = UPLOAD_DIR / txt_filename

        with open(txt_path, 'w', encoding='utf-8') as f:
            f.write(result['text'])

        logger.info(f"File TXT salvato: {txt_filename}")

        # Genera file SRT (sottotitoli YouTube)
        srt_filename = f"sottotitoli_{video_basename}_{timestamp}.srt"
        srt_path = UPLOAD_DIR / srt_filename

        with open(srt_path, 'w', encoding='utf-8') as f:
            for i, segment in enumerate(result['segments'], start=1):
                # Formato SRT:
                # 1
                # 00:00:00,000 --> 00:00:04,000
                # Testo del sottotitolo

                start_time = format_srt_timestamp(segment['start'])
                end_time = format_srt_timestamp(segment['end'])
                text = segment['text'].strip()

                f.write(f"{i}\n")
                f.write(f"{start_time} --> {end_time}\n")
                f.write(f"{text}\n\n")

        logger.info(f"File SRT salvato: {srt_filename}")

        # Rimuovi file audio temporaneo
        if audio_path.exists():
            audio_path.unlink()

        logger.info(f"Trascrizione completata per {video_path.name}")

        return {
            "success": True,
            "srt_filename": srt_filename,
            "txt_filename": txt_filename,
            "srt_path": f"/uploads/{srt_filename}",
            "txt_path": f"/uploads/{txt_filename}",
            "message": "Trascrizione completata con successo"
        }

    except subprocess.CalledProcessError as e:
        logger.error(f"Errore FFmpeg: {e.stderr if hasattr(e, 'stderr') else str(e)}")
        raise HTTPException(status_code=500, detail=f"Errore estrazione audio: {str(e)}")
    except Exception as e:
        logger.error(f"Errore trascrizione video: {e}")
        raise HTTPException(status_code=500, detail=f"Errore: {str(e)}")

def format_srt_timestamp(seconds):
    """Formatta i secondi in formato timestamp SRT (HH:MM:SS,mmm)"""
    hours = int(seconds // 3600)
    minutes = int((seconds % 3600) // 60)
    secs = int(seconds % 60)
    millis = int((seconds % 1) * 1000)

    return f"{hours:02d}:{minutes:02d}:{secs:02d},{millis:03d}"


# =====================================
# THUMBNAIL GENERATOR ENDPOINTS
# =====================================

@app.post("/api/thumbnail/upload-video")
async def upload_thumbnail_video(file: UploadFile = File(...)):
    """
    Upload del video per la generazione della miniatura
    """
    try:
        # Validazione tipo file
        if not file.content_type.startswith('video/'):
            raise HTTPException(status_code=400, detail="Il file deve essere un video")

        # Genera ID univoco
        file_id = str(uuid.uuid4())
        file_extension = Path(file.filename).suffix
        file_path = UPLOAD_DIR / f"thumb_video_{file_id}{file_extension}"

        # Salva il file
        logger.info(f"Salvataggio video per miniatura: {file_path}")
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)

        # Ottieni durata e info video
        try:
            result = subprocess.run(
                ['ffprobe', '-v', 'error', '-show_entries', 'format=duration',
                 '-of', 'default=noprint_wrappers=1:nokey=1', str(file_path)],
                capture_output=True,
                text=True,
                check=True
            )
            duration = float(result.stdout.strip())
        except:
            duration = 0

        return {
            "success": True,
            "file_id": file_id,
            "filename": file.filename,
            "duration": duration
        }

    except Exception as e:
        logger.error(f"Errore upload video miniatura: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/thumbnail/upload-image")
async def upload_thumbnail_image(file: UploadFile = File(...)):
    """
    Upload di un'immagine personalizzata per la miniatura
    """
    try:
        # Validazione tipo file
        if not file.content_type.startswith('image/'):
            raise HTTPException(status_code=400, detail="Il file deve essere un'immagine")

        # Genera ID univoco
        file_id = str(uuid.uuid4())
        file_extension = Path(file.filename).suffix
        file_path = UPLOAD_DIR / f"thumb_image_{file_id}{file_extension}"

        # Salva il file
        logger.info(f"Salvataggio immagine per miniatura: {file_path}")
        with open(file_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)

        return {
            "success": True,
            "file_id": file_id,
            "filename": file.filename,
            "preview_url": f"/uploads/thumb_image_{file_id}{file_extension}"
        }

    except Exception as e:
        logger.error(f"Errore upload immagine miniatura: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/thumbnail/extract-frame")
async def extract_video_frame(file_id: str = Form(...), timestamp: float = Form(5.0)):
    """
    Estrae un frame dal video al timestamp specificato
    """
    try:
        # Trova il file video
        video_path = None
        for ext in ['.mp4', '.avi', '.mov', '.mkv', '.webm']:
            test_path = UPLOAD_DIR / f"thumb_video_{file_id}{ext}"
            if test_path.exists():
                video_path = test_path
                break

        if not video_path:
            raise HTTPException(status_code=404, detail="Video non trovato")

        # Genera nome file output
        frame_id = str(uuid.uuid4())
        frame_path = UPLOAD_DIR / f"thumb_frame_{frame_id}.jpg"

        # Estrai frame con FFmpeg
        logger.info(f"Estrazione frame da {video_path} al secondo {timestamp}")
        subprocess.run(
            ['ffmpeg', '-ss', str(timestamp), '-i', str(video_path),
             '-vframes', '1', '-q:v', '2', str(frame_path)],
            capture_output=True,
            check=True
        )

        if not frame_path.exists():
            raise Exception("Frame non estratto correttamente")

        return {
            "success": True,
            "frame_id": frame_id,
            "preview_url": f"/uploads/thumb_frame_{frame_id}.jpg"
        }

    except subprocess.CalledProcessError as e:
        logger.error(f"Errore FFmpeg estrazione frame: {e}")
        raise HTTPException(status_code=500, detail="Errore estrazione frame dal video")
    except Exception as e:
        logger.error(f"Errore estrazione frame: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/thumbnail/generate")
async def generate_thumbnail(
    background_tasks: BackgroundTasks,
    source_type: str = Form(...),  # 'ai', 'upload', 'frame'
    file_id: Optional[str] = Form(None),
    style: str = Form('realistic'),
    description: Optional[str] = Form(None),
    add_text: bool = Form(False),
    text_content: Optional[str] = Form(None),
    text_position: str = Form('center'),
    text_color: str = Form('#FFFFFF'),
    text_bg_color: str = Form('#000000'),
    text_bg_opacity: int = Form(70)
):
    """
    Genera una miniatura YouTube professionale usando AI o immagine personalizzata
    """
    try:
        logger.info(f"Generazione miniatura - Tipo: {source_type}, Stile: {style}")

        # Crea job per tracking
        job_id = str(uuid.uuid4())
        with jobs_lock:
            processing_jobs[job_id] = ProcessingJob(job_id)

        # Avvia generazione in background
        background_tasks.add_task(
            process_thumbnail_generation,
            job_id, source_type, file_id, style, description,
            add_text, text_content, text_position,
            text_color, text_bg_color, text_bg_opacity
        )

        return {
            "success": True,
            "job_id": job_id,
            "message": "Generazione miniatura avviata"
        }

    except Exception as e:
        logger.error(f"Errore avvio generazione miniatura: {e}")
        raise HTTPException(status_code=500, detail=str(e))


def process_thumbnail_generation(
    job_id: str, source_type: str, file_id: Optional[str],
    style: str, description: Optional[str], add_text: bool,
    text_content: Optional[str], text_position: str,
    text_color: str, text_bg_color: str, text_bg_opacity: int
):
    """
    Processo di generazione miniatura (eseguito in background)
    """
    job = processing_jobs[job_id]

    try:
        from PIL import Image, ImageDraw, ImageFont
        import io
        import base64

        job.update(status="processing", progress=10, message="Preparazione immagine di base...")

        # STEP 1: Ottieni l'immagine base
        if source_type == 'ai':
            # Generazione AI con OpenAI DALL-E 3
            job.update(progress=20, message="Generazione immagine con AI...")
            base_image = generate_ai_thumbnail(style, description)

        elif source_type == 'upload':
            # Usa immagine caricata dall'utente
            job.update(progress=20, message="Caricamento immagine personalizzata...")
            for ext in ['.jpg', '.jpeg', '.png', '.webp']:
                img_path = UPLOAD_DIR / f"thumb_image_{file_id}{ext}"
                if img_path.exists():
                    base_image = Image.open(img_path)
                    break
            else:
                raise Exception("Immagine non trovata")

        elif source_type == 'frame':
            # Usa frame estratto dal video
            job.update(progress=20, message="Caricamento frame dal video...")
            frame_path = UPLOAD_DIR / f"thumb_frame_{file_id}.jpg"
            if not frame_path.exists():
                raise Exception("Frame non trovato")
            base_image = Image.open(frame_path)

        else:
            raise Exception(f"Tipo sorgente non valido: {source_type}")

        # STEP 2: Ridimensiona a formato YouTube ottimale (1280x720)
        job.update(progress=50, message="Ottimizzazione dimensioni per YouTube...")
        base_image = base_image.convert('RGB')
        base_image = base_image.resize((1280, 720), Image.Resampling.LANCZOS)

        # STEP 3: Aggiungi testo se richiesto
        if add_text and text_content:
            job.update(progress=70, message="Aggiunta testo sulla miniatura...")
            base_image = add_text_to_thumbnail(
                base_image, text_content, text_position,
                text_color, text_bg_color, text_bg_opacity
            )

        # STEP 4: Applica ottimizzazioni per aumentare CTR
        job.update(progress=85, message="Ottimizzazione finale per massimizzare i click...")
        base_image = enhance_thumbnail_for_ctr(base_image)

        # STEP 5: Salva il risultato
        job.update(progress=95, message="Salvataggio miniatura...")
        output_filename = f"thumbnail_{job_id}.jpg"
        output_path = OUTPUT_DIR / output_filename

        # Salva con alta qualit√† ma sotto i 2MB (limite YouTube)
        quality = 95
        base_image.save(output_path, 'JPEG', quality=quality, optimize=True)

        # Se supera 2MB, riduci qualit√†
        while output_path.stat().st_size > 2 * 1024 * 1024 and quality > 60:
            quality -= 5
            base_image.save(output_path, 'JPEG', quality=quality, optimize=True)

        file_size_mb = output_path.stat().st_size / (1024 * 1024)
        logger.info(f"Miniatura salvata: {output_path} ({file_size_mb:.2f} MB, qualit√† {quality})")

        # Aggiorna job come completato
        job.update(
            status="completed",
            progress=100,
            message="Miniatura generata con successo!",
            output_file=output_filename
        )
        save_jobs_state()

    except Exception as e:
        logger.error(f"Errore generazione miniatura (job {job_id}): {e}")
        job.update(
            status="error",
            message=f"Errore: {str(e)}",
            error=str(e)
        )
        save_jobs_state()


def generate_ai_thumbnail(style: str, description: Optional[str]) -> Image.Image:
    """
    Genera una miniatura usando OpenAI DALL-E 3
    """
    try:
        import openai
        import requests
        from PIL import Image
        import io

        # Configura OpenAI (richiede OPENAI_API_KEY nelle variabili d'ambiente)
        openai.api_key = os.getenv('OPENAI_API_KEY')

        if not openai.api_key:
            raise Exception(
                "OPENAI_API_KEY non configurata. "
                "Aggiungi la tua API key di OpenAI nelle variabili d'ambiente."
            )

        # Costruisci il prompt ottimizzato per miniature YouTube
        style_prompts = {
            'realistic': 'photorealistic, high detail, professional photography',
            'cinematic': 'cinematic lighting, epic composition, movie poster style',
            'cartoon': 'vibrant cartoon style, bold colors, animated look',
            'tech': 'futuristic technology, neon lights, digital art',
            'sport': 'dynamic action, sports photography, motion blur',
            'gaming': 'video game style, vibrant colors, action-packed',
            'business': 'professional, clean, modern business aesthetic',
            'minimal': 'minimalist design, clean lines, simple composition'
        }

        base_prompt = (
            f"Create a highly engaging YouTube thumbnail in {style_prompts.get(style, 'professional')} style. "
            f"The image should be eye-catching, have high contrast, and be optimized for small screens. "
        )

        if description:
            base_prompt += f"Content: {description}. "

        base_prompt += (
            "Make it attention-grabbing with bold visual elements. "
            "16:9 aspect ratio, optimized for YouTube thumbnails."
        )

        logger.info(f"Generazione AI con prompt: {base_prompt}")

        # Chiamata a DALL-E 3
        response = openai.images.generate(
            model="dall-e-3",
            prompt=base_prompt,
            size="1792x1024",  # Formato orizzontale
            quality="hd",
            n=1
        )

        # Scarica l'immagine generata
        image_url = response.data[0].url
        image_response = requests.get(image_url)
        image_response.raise_for_status()

        image = Image.open(io.BytesIO(image_response.content))
        logger.info("Immagine AI generata con successo")

        return image

    except ImportError:
        raise Exception(
            "Libreria 'openai' non installata. Esegui: pip install openai"
        )
    except Exception as e:
        logger.error(f"Errore generazione AI: {e}")
        raise Exception(f"Errore generazione AI: {str(e)}")


def add_text_to_thumbnail(
    image: Image.Image, text: str, position: str,
    text_color: str, bg_color: str, bg_opacity: int
) -> Image.Image:
    """
    Aggiunge testo con sfondo alla miniatura
    """
    try:
        from PIL import ImageDraw, ImageFont

        # Crea una copia dell'immagine
        img_with_text = image.copy()
        width, height = img_with_text.size

        # Crea layer per il testo
        txt_layer = Image.new('RGBA', (width, height), (255, 255, 255, 0))
        draw = ImageDraw.Draw(txt_layer)

        # Carica font (usa font di sistema o default)
        try:
            # Tenta di usare un font bold di sistema
            font_size = 80
            font = ImageFont.truetype("/System/Library/Fonts/Supplemental/Arial Bold.ttf", font_size)
        except:
            try:
                font = ImageFont.truetype("/usr/share/fonts/truetype/dejavu/DejaVuSans-Bold.ttf", font_size)
            except:
                # Fallback a font default
                font = ImageFont.load_default()

        # Calcola dimensioni testo
        bbox = draw.textbbox((0, 0), text, font=font)
        text_width = bbox[2] - bbox[0]
        text_height = bbox[3] - bbox[1]

        # Aggiungi padding
        padding = 30
        box_width = text_width + padding * 2
        box_height = text_height + padding * 2

        # Calcola posizione in base alla preferenza
        if position == 'top':
            x = (width - box_width) // 2
            y = height // 6
        elif position == 'bottom':
            x = (width - box_width) // 2
            y = height - height // 6 - box_height
        else:  # center
            x = (width - box_width) // 2
            y = (height - box_height) // 2

        # Disegna sfondo del testo con opacit√†
        bg_rgb = tuple(int(bg_color.lstrip('#')[i:i+2], 16) for i in (0, 2, 4))
        bg_alpha = int(255 * (bg_opacity / 100))
        draw.rounded_rectangle(
            [x, y, x + box_width, y + box_height],
            radius=15,
            fill=(*bg_rgb, bg_alpha)
        )

        # Disegna il testo
        text_rgb = tuple(int(text_color.lstrip('#')[i:i+2], 16) for i in (0, 2, 4))
        text_x = x + padding
        text_y = y + padding
        draw.text((text_x, text_y), text, font=font, fill=(*text_rgb, 255))

        # Combina con l'immagine originale
        img_with_text = Image.alpha_composite(img_with_text.convert('RGBA'), txt_layer)

        return img_with_text.convert('RGB')

    except Exception as e:
        logger.error(f"Errore aggiunta testo: {e}")
        # Ritorna l'immagine originale se fallisce
        return image


def enhance_thumbnail_for_ctr(image: Image.Image) -> Image.Image:
    """
    Applica ottimizzazioni per aumentare il CTR (Click-Through Rate) della miniatura
    """
    try:
        from PIL import ImageEnhance

        # Aumenta leggermente saturazione per colori pi√π vivaci
        enhancer = ImageEnhance.Color(image)
        image = enhancer.enhance(1.2)

        # Aumenta leggermente contrasto per maggiore impatto visivo
        enhancer = ImageEnhance.Contrast(image)
        image = enhancer.enhance(1.15)

        # Aumenta leggermente nitidezza
        enhancer = ImageEnhance.Sharpness(image)
        image = enhancer.enhance(1.3)

        return image

    except Exception as e:
        logger.error(f"Errore ottimizzazione miniatura: {e}")
        return image


# ============================================================================
# METADATA ENDPOINTS - Generazione metadati SEO YouTube con AI
# ============================================================================

@app.post("/api/metadata/upload-video")
async def upload_metadata_video(file: UploadFile = File(...)):
    """Upload video per generazione metadati"""
    try:
        # Validazione file
        if not file.content_type.startswith('video/'):
            raise HTTPException(status_code=400, detail="Il file deve essere un video")

        # Salva video temporaneamente
        file_ext = os.path.splitext(file.filename)[1]
        temp_filename = f"metadata_{uuid.uuid4()}{file_ext}"
        video_path = os.path.join(UPLOAD_DIR, temp_filename)

        with open(video_path, "wb") as buffer:
            shutil.copyfileobj(file.file, buffer)

        logger.info(f"Video caricato per metadati: {temp_filename}")

        return {
            "success": True,
            "filename": temp_filename,
            "path": video_path,
            "message": "Video caricato con successo"
        }

    except Exception as e:
        logger.error(f"Errore upload video metadati: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/metadata/generate")
async def generate_metadata(
    video_filename: str = Form(...),
    num_hashtags: int = Form(5),
    num_tags: int = Form(12),
    use_transcription: bool = Form(False)
):
    """Genera metadati AI dal video (con trascrizione opzionale)"""
    try:
        video_path = os.path.join(UPLOAD_DIR, video_filename)

        if not os.path.exists(video_path):
            raise HTTPException(status_code=404, detail="Video non trovato")

        # Genera metadati (con o senza trascrizione)
        metadata = await generate_metadata_from_transcription(
            video_path=video_path,
            num_hashtags=num_hashtags,
            num_tags=num_tags,
            use_transcription=use_transcription
        )

        logger.info(f"Metadati generati per {video_filename}")

        return {
            "success": True,
            "metadata": metadata,
            "message": "Metadati generati con successo"
        }

    except Exception as e:
        logger.error(f"Errore generazione metadati: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/metadata/customize")
async def customize_metadata(request: Request):
    """Applica personalizzazioni utente ai metadati"""
    try:
        data = await request.json()

        # Estrai dati
        base_metadata = data.get('metadata', {})
        customizations = data.get('customizations', {})

        # Applica personalizzazioni
        customized = merge_user_customizations(base_metadata, customizations)

        return {
            "success": True,
            "metadata": customized,
            "message": "Personalizzazioni applicate"
        }

    except Exception as e:
        logger.error(f"Errore personalizzazione metadati: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/metadata/format")
async def format_metadata(request: Request):
    """Formatta metadati per copia su YouTube"""
    try:
        data = await request.json()
        metadata = data.get('metadata', {})

        # Formatta per YouTube
        formatted = format_metadata_for_youtube(metadata)

        return {
            "success": True,
            "formatted": formatted,
            "message": "Metadati formattati per YouTube"
        }

    except Exception as e:
        logger.error(f"Errore formattazione metadati: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ============================================================================
# VIDEO TRANSLATION ENDPOINTS - Traduzione video con audio e lip-sync
# ============================================================================

@app.get("/api/translation/languages")
async def get_supported_languages():
    """Ottieni lista lingue supportate per traduzione"""
    try:
        translator = VideoTranslator()
        return {
            "success": True,
            "languages": translator.supported_languages
        }
    except Exception as e:
        logger.error(f"Errore get lingue: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/translation/translate-video")
async def translate_video_endpoint(
    background_tasks: BackgroundTasks,
    video_file_id: str = Form(...),
    target_language: str = Form(...),
    source_language: str = Form('auto'),
    enable_lipsync: bool = Form(False),
    keep_original_audio: bool = Form(True)
):
    """
    Avvia traduzione video in background

    Args:
        file_id: ID del video da tradurre (senza estensione)
        target_language: Codice lingua target (es. 'en', 'es', 'fr')
        source_language: Codice lingua sorgente (default: 'auto' per rilevamento automatico)

    Returns:
        Job ID per tracking progresso

    Note:
        Per lip-sync professionale, considera l'integrazione con ElevenLabs API
        che offre video dubbing con sincronizzazione labiale automatica.
    """
    try:
        logger.info(f"Richiesta traduzione video: {video_file_id} ({source_language}) -> {target_language}, lip-sync: {enable_lipsync}")

        # Trova video input
        video_path = None
        video_extensions = ['.mp4', '.avi', '.mov', '.mkv', '.webm']

        for ext in video_extensions:
            test_path = UPLOAD_DIR / f"{video_file_id}{ext}"
            if test_path.exists():
                video_path = test_path
                break

        # Prova anche con prefissi comuni
        if not video_path:
            for prefix in ['web_video_', 'recording_', 'metadata_']:
                for ext in video_extensions:
                    test_path = UPLOAD_DIR / f"{prefix}{video_file_id}{ext}"
                    if test_path.exists():
                        video_path = test_path
                        break
                if video_path:
                    break

        if not video_path:
            raise HTTPException(status_code=404, detail=f"Video non trovato per ID: {video_file_id}")

        logger.info(f"Video trovato: {video_path}")

        # Crea job per tracking
        job_id = str(uuid.uuid4())
        job = ProcessingJob(job_id)

        with jobs_lock:
            processing_jobs[job_id] = job

        save_jobs_state()

        # Avvia traduzione in background
        background_tasks.add_task(
            process_video_translation,
            job,
            str(video_path),
            target_language,
            source_language,
            enable_lipsync,
            keep_original_audio
        )

        logger.info(f"Job traduzione creato: {job_id}")

        return {
            "success": True,
            "job_id": job_id,
            "message": "Traduzione video avviata"
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Errore avvio traduzione: {e}")
        raise HTTPException(status_code=500, detail=str(e))


async def process_video_translation(
    job: ProcessingJob,
    video_path: str,
    target_language: str,
    source_language: str,
    enable_lipsync: bool = False,
    keep_original_audio: bool = True
):
    """
    Processo di traduzione video (eseguito in background)

    Args:
        job: ProcessingJob per tracking
        video_path: Path video input
        target_language: Lingua target
        source_language: Lingua sorgente ('auto' per rilevamento automatico)
    """
    try:
        job.update(status="processing", progress=5, message="Inizializzazione traduzione...")
        save_jobs_state()

        # Output path
        output_filename = f"translated_{job.job_id}.mp4"
        output_path = OUTPUT_DIR / output_filename

        # Crea translator
        translator = VideoTranslator(temp_dir=str(UPLOAD_DIR))

        # Progress callback per aggiornare job
        def progress_callback(progress: int, message: str) -> bool:
            """Callback per aggiornamento progresso"""
            try:
                # Controlla se job deve essere fermato
                if job.should_stop:
                    logger.info(f"Traduzione {job.job_id} interrotta per richiesta utente")
                    return False

                # Aggiorna progress
                job.update(progress=progress, message=message)

                # Salva stato ogni 10%
                if progress % 10 == 0:
                    save_jobs_state()

                return True

            except Exception as e:
                logger.error(f"Errore callback progress: {e}")
                return True

        # Esegui traduzione
        logger.info(f"Avvio traduzione video: {video_path} ({source_language}) -> {target_language}")

        success = translator.translate_video(
            input_video_path=video_path,
            output_video_path=str(output_path),
            target_language=target_language,
            source_language=source_language,
            enable_lipsync=enable_lipsync,
            progress_callback=progress_callback
        )

        if success and output_path.exists():
            job.update(
                status="completed",
                progress=100,
                message="‚úÖ Video tradotto con successo!",
                output_file=f"/outputs/{output_filename}"
            )
            logger.info(f"Traduzione completata: {job.job_id}")
        else:
            raise Exception("Errore durante traduzione video")

    except Exception as e:
        logger.error(f"Errore traduzione job {job.job_id}: {e}")
        job.update(
            status="error",
            message=f"‚ùå Errore: {str(e)}",
            error=str(e)
        )

    finally:
        save_jobs_state()


@app.get("/api/translation/download/{job_id}")
async def download_translated_video(job_id: str):
    """Download video tradotto"""
    try:
        with jobs_lock:
            if job_id not in processing_jobs:
                raise HTTPException(status_code=404, detail="Job non trovato")

            job = processing_jobs[job_id]

        if job.status != "completed" or not job.output_file:
            raise HTTPException(status_code=400, detail="Traduzione non completata")

        # Estrai filename dall'output_file path
        filename = job.output_file.replace("/outputs/", "")
        output_path = OUTPUT_DIR / filename

        if not output_path.exists():
            raise HTTPException(status_code=404, detail="File tradotto non trovato")

        return FileResponse(
            path=output_path,
            filename=f"video_tradotto_{job_id}.mp4",
            media_type="video/mp4"
        )

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Errore download video tradotto: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ============================================================================
# YOUTUBE UPLOAD ENDPOINTS - Upload video su YouTube con OAuth2
# ============================================================================

@app.get("/api/youtube/status")
async def youtube_status():
    """Verifica se l'utente √® autenticato con YouTube"""
    try:
        is_auth = youtube_uploader.is_authenticated()

        channel_info = None
        if is_auth:
            channel_info = youtube_uploader.get_channel_info()

        return {
            "authenticated": is_auth,
            "channel": channel_info if is_auth else None
        }
    except Exception as e:
        logger.error(f"Errore status YouTube: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/api/youtube/auth")
async def youtube_auth():
    """Inizia il flusso OAuth2 per YouTube"""
    try:
        auth_url = youtube_uploader.get_auth_url(
            redirect_uri="http://localhost:8000/api/youtube/oauth2callback"
        )

        return {
            "auth_url": auth_url,
            "message": "Apri questo URL nel browser per autorizzare l'accesso a YouTube"
        }
    except FileNotFoundError as e:
        raise HTTPException(
            status_code=400,
            detail=str(e)
        )
    except Exception as e:
        logger.error(f"Errore avvio auth YouTube: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/api/youtube/oauth2callback")
async def youtube_oauth_callback(request: Request):
    """Callback OAuth2 da Google"""
    try:
        # Ottieni URL completo con parametri
        full_url = str(request.url)

        # Completa autenticazione
        success = youtube_uploader.handle_oauth_callback(full_url)

        if success:
            # Redirect alla home con messaggio successo
            return HTMLResponse("""
                <html>
                    <head>
                        <title>Autenticazione Completata</title>
                        <style>
                            body {
                                font-family: Arial, sans-serif;
                                display: flex;
                                justify-content: center;
                                align-items: center;
                                height: 100vh;
                                margin: 0;
                                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                            }
                            .container {
                                background: white;
                                padding: 40px;
                                border-radius: 15px;
                                box-shadow: 0 10px 40px rgba(0,0,0,0.2);
                                text-align: center;
                            }
                            .success-icon {
                                font-size: 64px;
                                color: #28a745;
                                margin-bottom: 20px;
                            }
                            h1 {
                                color: #333;
                                margin-bottom: 10px;
                            }
                            p {
                                color: #666;
                                margin-bottom: 30px;
                            }
                            .btn {
                                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                                color: white;
                                padding: 12px 30px;
                                border-radius: 8px;
                                text-decoration: none;
                                display: inline-block;
                                font-weight: bold;
                            }
                        </style>
                    </head>
                    <body>
                        <div class="container">
                            <div class="success-icon">‚úì</div>
                            <h1>Autenticazione Completata!</h1>
                            <p>Il tuo account YouTube √® stato collegato con successo.</p>
                            <a href="/" class="btn">Torna all'App</a>
                        </div>
                        <script>
                            // Auto-chiudi dopo 3 secondi
                            setTimeout(() => {
                                window.close();
                                window.location.href = '/';
                            }, 3000);
                        </script>
                    </body>
                </html>
            """)
        else:
            raise HTTPException(status_code=400, detail="Autenticazione fallita")

    except Exception as e:
        logger.error(f"Errore callback OAuth: {e}")
        return HTMLResponse(f"""
            <html>
                <body>
                    <h1>Errore Autenticazione</h1>
                    <p>{str(e)}</p>
                    <a href="/">Torna alla Home</a>
                </body>
            </html>
        """, status_code=400)


@app.post("/api/youtube/disconnect")
async def youtube_disconnect():
    """Disconnette l'account YouTube"""
    try:
        success = youtube_uploader.disconnect()

        if success:
            return {
                "success": True,
                "message": "Account YouTube disconnesso"
            }
        else:
            raise HTTPException(status_code=500, detail="Errore disconnessione")

    except Exception as e:
        logger.error(f"Errore disconnessione YouTube: {e}")
        raise HTTPException(status_code=500, detail=str(e))


@app.post("/api/youtube/upload")
async def youtube_upload_video(
    background_tasks: BackgroundTasks,
    file_id: str = Form(...),
    title: str = Form(...),
    description: str = Form(""),
    tags: str = Form(""),  # Comma-separated
    privacy: str = Form("private")  # private, unlisted, public
):
    """
    Carica un video su YouTube

    Args:
        file_id: ID del file video (senza estensione)
        title: Titolo del video
        description: Descrizione del video
        tags: Tag separati da virgola
        privacy: Visibilit√† (private, unlisted, public)
    """
    try:
        # Verifica autenticazione
        if not youtube_uploader.is_authenticated():
            raise HTTPException(
                status_code=401,
                detail="Non autenticato. Collega il tuo account YouTube prima."
            )

        # Trova video file
        video_path = None
        video_extensions = ['.mp4', '.avi', '.mov', '.mkv', '.webm']

        # Cerca in uploads
        for ext in video_extensions:
            test_path = UPLOAD_DIR / f"{file_id}{ext}"
            if test_path.exists():
                video_path = test_path
                break

        # Cerca in outputs
        if not video_path:
            for ext in video_extensions:
                test_path = OUTPUT_DIR / f"{file_id}{ext}"
                if test_path.exists():
                    video_path = test_path
                    break

        # Prova con prefissi comuni
        if not video_path:
            for prefix in ['web_video_', 'recording_', 'metadata_', 'translated_', 'thumb_video_']:
                for ext in video_extensions:
                    test_path = UPLOAD_DIR / f"{prefix}{file_id}{ext}"
                    if test_path.exists():
                        video_path = test_path
                        break
                    test_path = OUTPUT_DIR / f"{prefix}{file_id}{ext}"
                    if test_path.exists():
                        video_path = test_path
                        break
                if video_path:
                    break

        if not video_path:
            raise HTTPException(
                status_code=404,
                detail=f"Video non trovato per ID: {file_id}"
            )

        logger.info(f"Upload YouTube richiesto: {video_path}")

        # Converti tags da string a lista
        tags_list = [tag.strip() for tag in tags.split(',') if tag.strip()]

        # Crea job per tracking
        job_id = str(uuid.uuid4())
        job = ProcessingJob(job_id)

        with jobs_lock:
            processing_jobs[job_id] = job

        save_jobs_state()

        # Avvia upload in background
        background_tasks.add_task(
            process_youtube_upload,
            job,
            str(video_path),
            title,
            description,
            tags_list,
            privacy
        )

        logger.info(f"Job YouTube upload creato: {job_id}")

        return {
            "success": True,
            "job_id": job_id,
            "message": "Upload su YouTube avviato"
        }

    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"Errore avvio upload YouTube: {e}")
        raise HTTPException(status_code=500, detail=str(e))


async def process_youtube_upload(
    job: ProcessingJob,
    video_path: str,
    title: str,
    description: str,
    tags: List[str],
    privacy: str
):
    """
    Processo di upload video su YouTube (eseguito in background)
    """
    try:
        job.update(
            status="processing",
            progress=5,
            message="Preparazione upload su YouTube..."
        )
        save_jobs_state()

        # Progress callback
        def progress_callback(progress: int) -> bool:
            """Callback per aggiornamento progresso"""
            try:
                # Check cancellazione
                if job.should_stop:
                    logger.info(f"Upload YouTube {job.job_id} interrotto")
                    return False

                # Aggiorna progress (5-95%)
                actual_progress = 5 + int(progress * 0.9)
                job.update(
                    progress=actual_progress,
                    message=f"Upload su YouTube... {progress}%"
                )

                # Salva ogni 10%
                if progress % 10 == 0:
                    save_jobs_state()

                return True

            except Exception as e:
                logger.error(f"Errore callback progress YouTube: {e}")
                return True

        # Esegui upload
        logger.info(f"Avvio upload YouTube: {title}")

        result = youtube_uploader.upload_video(
            video_path=video_path,
            title=title,
            description=description,
            tags=tags,
            privacy_status=privacy,
            progress_callback=progress_callback
        )

        if result.get('success'):
            video_url = result.get('video_url')
            video_id = result.get('video_id')

            job.update(
                status="completed",
                progress=100,
                message=f"‚úÖ Video caricato su YouTube!",
                output_file=video_url  # Salva URL YouTube
            )

            logger.info(f"Upload YouTube completato: {video_url}")
        else:
            raise Exception(result.get('error', 'Upload fallito'))

    except Exception as e:
        logger.error(f"Errore upload YouTube job {job.job_id}: {e}")
        job.update(
            status="error",
            message=f"‚ùå Errore upload YouTube: {str(e)}",
            error=str(e)
        )

    finally:
        save_jobs_state()


# ============================================================================
# ZIP DOWNLOAD ENDPOINT - Scarica tutti i file di un job come ZIP
# ============================================================================

class DownloadZipRequest(BaseModel):
    job_id: str
    files: List[str]

@app.post("/api/download-job-zip")
async def download_job_zip(request: DownloadZipRequest):
    """
    Crea uno ZIP con tutti i file generati da un job e lo restituisce per il download
    """
    try:
        import zipfile
        from io import BytesIO

        logger.info(f"Creazione ZIP per job {request.job_id} con {len(request.files)} file")

        # Crea ZIP in memoria
        zip_buffer = BytesIO()

        with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
            for file_path in request.files:
                # Controlla che il file esista
                full_path = Path(file_path)
                if not full_path.exists():
                    logger.warning(f"File non trovato: {file_path}")
                    continue

                # Aggiungi file allo ZIP con il nome del file (senza percorso completo)
                arcname = full_path.name
                zip_file.write(full_path, arcname)
                logger.info(f"Aggiunto allo ZIP: {arcname}")

        # Prepara lo ZIP per il download
        zip_buffer.seek(0)

        from fastapi.responses import StreamingResponse

        return StreamingResponse(
            zip_buffer,
            media_type="application/zip",
            headers={
                "Content-Disposition": f"attachment; filename=job_{request.job_id}_files.zip"
            }
        )

    except Exception as e:
        logger.error(f"Errore creazione ZIP: {e}")
        raise HTTPException(status_code=500, detail=f"Errore creazione ZIP: {str(e)}")


if __name__ == "__main__":
    uvicorn.run("app:app", host="0.0.0.0", port=8000, reload=True)